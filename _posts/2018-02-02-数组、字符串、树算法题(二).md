---
layout:     post
title:      一些算法题
date:       2018-02-02
author:     zrd
catalog:    true
tags:
    - 算法
---

### 数组中出现次数超过一半的数字

普通解法
```
function MoreThanHalfNum_Solution(numbers){
    var len = numbers.length;
    for(let i = 0; i < len / 2; i++){
        var count = 1;
        for(let j = 0; j < len; j++){
            if(j === i){

continue;
            }
            if(numbers[i] === numbers[j]){
                count++
            }
        }        
        if(count > len / 2){
            return numbers[i]
        }else{
            continue
        }
    }
    return 0
}
```

数组排序后,若有符合条件的数,一定是中间的数
```
function MoreThanHalfNum_Solution(numbers){
    numbers.sort();
    var len = numbers.length,
        middle = numbers[Math.floor(len / 2)],
        count = 0;
    
    for(let i = 0; i < len; i++){
        if(numbers[i] === middle){
            count++
        }
    }
    return count > len / 2 ? middle : 0
}
```

### 连续子数组的最大和

最普通的方法

利用两个循环将每个和都算出来
```
function FindGreatestSumOfSubArray(array){
    //第一个最大值不能设为0,因为所求和可能为负值
    var maxNum = array[0],
        currNum = 0;
    for(let i = 0; i < array.length; i++){
        currNum = 0;
        for(let j = i; j < array.length; j++){
           currNum += array[j];
            if(currNum > maxNum){
                maxNum = currNum
            }
        }
    }
    return maxNum
}
```

sum数组法

设sum[i] = A[0]+A[1]+……+A[i] 
记S[i,j]为从子数组A[i]…A[j]的和,则S[i,j] = sum[j] - sum[i-1], 
要求出最大的S[i, j],则要使sum[i-1]保持最小
```
function FindGreatestSumOfSubArray(array){
    var arr = [];
    arr.push(array[0]);
    for(let i = 1; i < array.length; i++){
        arr.push(arr[i - 1] + array[i]);
    }
    var min = 0,
        max = arr[0];
    for(let j = 1; j < array.length; j++){
        //找出j以前的最小值
        if(min > arr[j - 1]){
            min = arr[j - 1]
        }
        //保存最大值
        if(max < arr[j] - min){
            max = arr[j] - min
        }
    }
    return max
}
```

### 整数中1出现的次数

将n的各个位分为两类：个位与其它位。 
对个位来说：
若个位大于0,1出现的次数为round * 1 + 1
若个位等于0,1出现的次数为round * 1
对其它位来说:
记每一位的权值为base,位值为weight,该位之前的数是former
若weight为0,则1出现次数为round * base
若weight为1,则1出现次数为round * base + former + 1
若weight大于1,则1出现次数为rount * base + base
```
function NumberOf1Between1AndN_Solution(n){
    if(n < 1){
        return 0
    }
    var count = 0,
        round = n,
        base = 1;    
    while(round > 0){
        var weight = round % 10;
        round = Math.floor(round / 10);
        count += base * round;
        if(weight === 1){
            count += n % base + 1;
        }else if(weight > 1){
            count += base;
        }
        base *= 10;
    }
    return count
}
```

### 求按从小到大的第n个丑数()

简单方法
首先除2，直到不能整除为止，然后除5到不能整除为止，然后除3直到不能整除为止。最终判断剩余的数字是否为1，如果是1则为丑数，否则不是丑数
```
function GetUglyNumber_Solution(index){
    var uglyNum = 0,
        n = 0;
    while(uglyNum < index){
        var num = n;
        n++;
        while(num % 2 === 0){
            num = num / 2;
        }
        while(num % 3 === 0){
            num = num / 3;
        }
        while(num % 5 === 0){
            num = num / 5;
        }
        if(num === 1){
            uglyNum++;
        }
    }
    return n - 1;
}
```

第二种方法
首先定义一个数组存放丑数,认为1是丑数,则初始化数组num[0] = 1,然后从2,3,5这三个种子中挑选,选择num[0]*2,num[0]*3,num[0]*5中最小的数为新的丑数,即2。
然后在从2,3,5中选择,这时应该是从num[1]*2,num[0]*3,num[0]*5中进行选择,显然选择3。然后再从num[1]*2，num[1]*3，num[0]*5中选择最小的,即4。
依次进行如下操作
```
function GetUglyNumber_Solution(index){
    if(index === 0){
        return 0
    }
    var uglyNum = [];
        uglyNum[0] = 1;
    var num_2 = 0,
        num_3 = 0,
        num_5 = 0;   
    for(let i = 1; i < index; i++){
        uglyNum[i] = Math.min(uglyNum[num_2] * 2, uglyNum[num_3] * 3, uglyNum[num_5] * 5);
        if(uglyNum[i] / uglyNum[num_2] === 2){
            num_2++;
        }
        if(uglyNum[i] / uglyNum[num_3] === 3){
            num_3++;
        }
        if(uglyNum[i] / uglyNum[num_5] === 5){
            num_5++;
        }
    }
    return uglyNum[index - 1]
}
```

### 第一个只出现一次的字符串

在一个字符串(1<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置


```
function FirstNotRepeatingChar(str){
    if(str === ''){
        return -1
    }
    for(let i = 0; i < str.length; i++){
        var index = str.indexOf(str[i]);
        if(index === i){
            var another = str.indexOf(str[i], index + 1);
            if(another === -1){
                return i
            }
        }
    }
}
```



















