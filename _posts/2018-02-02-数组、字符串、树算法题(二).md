---
layout:     post
title:      一些算法题
date:       2018-02-02
author:     zrd
catalog:    true
tags:
    - 算法
---

### 数组中出现次数超过一半的数字

普通解法
```
function MoreThanHalfNum_Solution(numbers){
    var len = numbers.length;
    for(let i = 0; i < len / 2; i++){
        var count = 1;
        for(let j = 0; j < len; j++){
            if(j === i){

continue;
            }
            if(numbers[i] === numbers[j]){
                count++
            }
        }        
        if(count > len / 2){
            return numbers[i]
        }else{
            continue
        }
    }
    return 0
}
```

数组排序后,若有符合条件的数,一定是中间的数
```
function MoreThanHalfNum_Solution(numbers){
    numbers.sort();
    var len = numbers.length,
        middle = numbers[Math.floor(len / 2)],
        count = 0;
    
    for(let i = 0; i < len; i++){
        if(numbers[i] === middle){
            count++
        }
    }
    return count > len / 2 ? middle : 0
}
```

### 连续子数组的最大和

最普通的方法

利用两个循环将每个和都算出来
```
function FindGreatestSumOfSubArray(array){
    //第一个最大值不能设为0,因为所求和可能为负值
    var maxNum = array[0],
        currNum = 0;
    for(let i = 0; i < array.length; i++){
        currNum = 0;
        for(let j = i; j < array.length; j++){
           currNum += array[j];
            if(currNum > maxNum){
                maxNum = currNum
            }
        }
    }
    return maxNum
}
```

sum数组法

设sum[i] = A[0]+A[1]+……+A[i] 
记S[i,j]为从子数组A[i]…A[j]的和,则S[i,j] = sum[j] - sum[i-1], 
要求出最大的S[i, j],则要使sum[i-1]保持最小
```
function FindGreatestSumOfSubArray(array){
    var arr = [];
    arr.push(array[0]);
    for(let i = 1; i < array.length; i++){
        arr.push(arr[i - 1] + array[i]);
    }
    var min = 0,
        max = arr[0];
    for(let j = 1; j < array.length; j++){
        //找出j以前的最小值
        if(min > arr[j - 1]){
            min = arr[j - 1]
        }
        //保存最大值
        if(max < arr[j] - min){
            max = arr[j] - min
        }
    }
    return max
}
```

### 整数中1出现的次数

将n的各个位分为两类：个位与其它位。 
对个位来说：
若个位大于0,1出现的次数为round * 1 + 1
若个位等于0,1出现的次数为round * 1
对其它位来说:
记每一位的权值为base,位值为weight,该位之前的数是former
若weight为0,则1出现次数为round * base
若weight为1,则1出现次数为round * base + former + 1
若weight大于1,则1出现次数为rount * base + base
```
function NumberOf1Between1AndN_Solution(n){
    if(n < 1){
        return 0
    }
    var count = 0,
        round = n,
        base = 1;    
    while(round > 0){
        var weight = round % 10;
        round = Math.floor(round / 10);
        count += base * round;
        if(weight === 1){
            count += n % base + 1;
        }else if(weight > 1){
            count += base;
        }
        base *= 10;
    }
    return count
}
```






















