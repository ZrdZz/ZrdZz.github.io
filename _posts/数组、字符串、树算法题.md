---
layout:     post
title:      一些算法题
date:       2018-01-01
author:     zrd
catalog:    true
tags:
    - 算法
---

### 二维数组的查找

在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

1. 因为每一行或每一列都是有序的,所以可以对每一行进行二分查找,时间复杂度为nlogn
```
function Find(target, array)
{
    //每一行进行二分查找
	var len = array.length;
    for(let i = 0; i < len; i++){
        var low = 0,
            high = len - 1;
        while(low <= high){
            let mid = Math.floor((low + high) / 2);
            if(array[i][mid] === target){
                return true
            }else if(array[i][mid] > target){
                high = mid - 1;
            }else{
                low = mid + 1;
            }
        }
    }
    return false
}
```

2. 因为从左到右从上到下都是递增的,所以可以选择从左下或右上开始,若从左下开始,当其大于target,则target位于上方,小于target,位于右方
```
function Find(target, array)
{
    var len = array.length,
        i = len - 1,
        j = 0;
     
    while(i > -1 && j < len){
        if(array[i][j] === target){
            return true
        }else if(array[i][j] <= target){
            j++;
        }else{
            i--;
        }
    }
    return false
}
```

### 替换字符串中的空格

将一个字符串中的空格替换成"%20"。

```
function replaceSpace(str)
{
    return str.replace(/\s/g, '%20');
}
```

注意`replace`方法没有改变原字符串

### 重建二叉树

输入某二叉树的前序遍历和中序遍历的结果,重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6},则重建二叉树并返回

```
/*  function TreeNode(x) {
 *     this.val = x;
 *     this.left = null;
 *     this.right = null;
 */ }
 
//pre是先序遍历序列,vin是中序遍历序列
function reConstructBinaryTree(pre, vin){
    if(!pre || pre.length === 0){
        return
    }
    
    var treeNode = {
        val: pre[0]
    }
    
    for(let i = 0, len = pre.length; i < len; i++){
        if(pre[0] === vin[i]){
            treeNode.left = reConstructBinaryTree(pre.slice(1, i + 1), vin.slice(0, i));
            treeNode.right = reConstructBinaryTree(pre.slice(i + 1), vin.slice(i + 1))
        }
    }
    return treeNode
}
```

- 前序遍历: 根左右
- 中序遍历：左根右          
- 后序遍历：左右根         

1. 先序遍历的第一个节点就是树的根节点,中序遍历的根节点位于中间的某个位置p
2. 首先遍历序列找到中序遍历根节点的位置,即p,p左边的序列为根节点的左子树,右边的序列为右子树
3. 根据p在前序遍历数组中截取出左右子树
4. 递归,分别找出左右子树的根节点及它的左右子树

### 用两个栈实现队列

用两个栈来实现一个队列，完成队列的Push和Pop操作

```
var stack1 = [],
    stack2 = [];

function push(node){
    stack1.push(node);
}

function pop(){
    if(stack2.length === 0){
        for(var i = 0, len = stack1.length; i < len; i++){
            stack2.push(stack1.pop());
        }
    }
    return stack2.pop()
}
```

首先可能会想到: 入栈的话直接入stack1,出栈时先将元素从stack1中pop出来,在push到stack2中,然后再pop出一个元素,最后再将元素倒回stack1中。
仔细想想其实如果出栈时先判断一下stack2中有没有元素,若没有说明都在stack1中,将其元素倒入stack2中,再pop出来;若有则直接pop出来,这样减少倒入倒出的次数。










