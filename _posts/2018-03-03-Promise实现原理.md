---
layout:     post
title:      Promise基本原理
date:       2018-03-03
author:     zrd
catalog:    true
tags:
    - JS
---

Promise类似于一个容器, 里面一般保存了一个异步操作。

有两个特点:
1. Promise对象有三种状态`pending`、`fulfilled`、`rejected`, 异步操作可以决定当前是哪一种状态。
2. 只能从pending变为fulfilled或从pending变为rejected, 一旦状态改变就不会再发生变化, 并且改变后再添加回调函数也可触发。

先写一个简单版:
```
function Promise(fn){
  var callbacks = [],
      value;
  
  //类似于一个观察者模式, 通过then方法来注册监听者
  this.then = function(res){
    callbacks.push(res);
  }
  
  //在resolve中执行回调函数
  function resolve(value){
    callbacks.forEach(function(callback){
      callback(value)
    });
  }
  
  fn(resolve)
}
```

有一点问题, 在Promise结束后, 添加回调函数不会执行; 而且如果fn中是一个同步操作的话, 执行resolve时callbacks是空的。
```
function Promise(fn){
  var callbacks = [],
      value,
      state = 'pending';
  
  //添加state, 当state为pending时, 将其添加到队列中, 若不为说明这时Promise已经执行完, 直接执行回调函数
  this.then = function(onFulfilled){
    if(state === 'pending'){
      callbacks.push(onFulfilled);
      return
    }
    
    onFulfilled(value);
  }
  
  function resolve(newValue){
    value = newValue
    state = 'fulfilled';
    
    //利用setTimeout将callbacks的执行添加到消息队列中, 这样当他执行时保证then已执行完
    setTimeout(function(){
      callbacks.forEach(function(onFulfilled){
        //通过给value赋值, 可以将前一个callback的返回值赋给下一个callback
        value = onFulfilled(value)
      })
    }, 0)
  }
  
  fn(resolve)
}
```

串行Promise是指在当前Promise达到fulfilled状态后, 即开始进行下一个Promise
```
function Promise(fn){
  var callbacks = [],
      value,
      state = 'pending';
  
  this.then = function(onFulfilled){
    if(state === 'pending'){
      callbacks.push(onFulfilled);
      return
    }
    
    onFulfilled(value);
  }
  
  function resolve(newValue){
    value = newValue
    state = 'fulfilled';
    
    setTimeout(function(){
      callbacks.forEach(function(onFulfilled){
        value = onFulfilled(value)
      })
    }, 0)
  }
  
  fn(resolve)
}
```





























